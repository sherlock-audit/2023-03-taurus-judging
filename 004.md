ahmedovv

medium

# Possible DoS in FeeSplitter that no one can receive fees.

## Summary

Currentyly ```feeSpliter.sol``` uses *push over pull* pattern which sends ERC20 tokens to multiple addresses with one single tx.
This pattern is aplied on eth transfers but in this scenario where return data is checked and there is possibility to revert the transaction, it is recommenden to use *pull over push* pattern for ERC20 also.

## Vulnerability Detail

If one of these addresses in ```feeRecipients``` array is not *friendly* and returns ```false``` on ```safeTransfer```, will revert the whole transaction because of the ```SafeERC20``` library and no one will receive any tokens.

## Impact

## Code Snippet

https://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Tokenomics/FeeSplitter.sol#L28-L40

```solidity
    function distributeFees(address _token) external {
        uint256 feeAmount = IERC20(_token).balanceOf(address(this));
        if (feeAmount == 0) return;

        uint256 _numFeeRecipients = numFeeRecipients;
        for (uint256 i; i < _numFeeRecipients; ++i) {
            FeeRecipient memory feeRecipient = feeRecipients[i];
            IERC20(_token).safeTransfer(
                feeRecipient.recipient,
                (feeAmount * feeRecipient.proportion) / Constants.PERCENT_PRECISION
            );
        }
    }
```

## Tool used

Manual Review

## Recommendation

Recommended way to this approach is to use something like ```withdrawFees```

```solidity
    function withdrawFees() external {
        uint256 feeAmount = IERC20(_token).balanceOf(address(this));
        if (feeAmount == 0) return;

        for (uint256 i; i < _numFeeRecipients; ++i) {
            if (mgs.sender == feeRecipients[i].recipient) {
                IERC20(_token).safeTransfer(
                    msg.sender
                    (feeAmount * feeRecipient.proportion) / Constants.PERCENT_PRECISION
                );

                return;
            }
        }
    }
```
